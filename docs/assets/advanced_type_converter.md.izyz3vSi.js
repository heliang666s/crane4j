import{_ as e,c as t,o as r,a4 as o}from"./chunks/framework.CTZgbW0d.js";const v=JSON.parse('{"title":"类型转换器","description":"","frontmatter":{},"headers":[],"relativePath":"advanced/type_converter.md","filePath":"advanced/type_converter.md","lastUpdated":1709128937000}'),d={name:"advanced/type_converter.md"},a=o('<h1 id="类型转换器" tabindex="-1">类型转换器 <a class="header-anchor" href="#类型转换器" aria-label="Permalink to &quot;类型转换器&quot;">​</a></h1><p>在 <code>crane4j</code> 中有不少需要通过反射调用有参方法的场景，包括且不限于：</p><ul><li>在字段映射时调用的 <code>setter</code> 方法；</li><li>从方法数据源容器调用适配方法以获取数据源；</li><li>调用操作接口以填充对象的参数；</li></ul><p>这些方法底层都依赖于类型转换器管理器 <code>ConverterManager</code> 来实现参数的自动转换。换句话说，如果方法的参数类型是 A，而输入的参数类型是 B，<code>ConverterManager</code> 将会自动尝试将 B 转换为 A 类型。</p><p><code>ConverterManager</code> 目前提供了三套实现：</p><table><thead><tr><th>转换器</th><th>说明</th><th>使用情况</th></tr></thead><tbody><tr><td><code>SimpleConverterManager</code></td><td>直接通过 <code>(R)t</code> 这种方式强转，作用有限</td><td>基本只在测试用例中使用</td></tr><tr><td><code>HutoolConverterManager</code></td><td>基于 Hutool 的 <code>Convert</code> 实现，参见 Hutool 参考文档中的 <a href="https://hutool.cn/docs/#/core/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-ConverterRegistry?id=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-converterregistry" target="_blank" rel="noreferrer">自定义类型转换-ConverterRegistry</a> 一节</td><td>在非 Spring 环境中使用</td></tr><tr><td><code>SpringConverterManager</code></td><td>基于 Spring 的 <code>ConversionService</code> 实现，功能强大</td><td>在 Spring 环境下使用</td></tr></tbody></table><p>基于此，如果你要添加新的类型转换器，那么在 Spring 环境，你只需要与 Spring 对接，而在非 Spring 环境，你只需要与 Hutool 对接。</p><p>不过，你也可以实现 <code>ConverterManager</code> 接口，定义你的自己的类型转换器。</p>',8),n=[a];function c(i,p,l,_,s,E){return r(),t("div",null,n)}const B=e(d,[["render",c]]);export{v as __pageData,B as default};
